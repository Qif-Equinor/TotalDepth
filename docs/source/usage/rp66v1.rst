.. moduleauthor:: Paul Ross <apaulross@gmail.com>
.. sectionauthor:: Paul Ross <apaulross@gmail.com>

.. Description of CPIP command line tools

.. _total_depth.processing_rp66v1_files:


Processing RP66V1 Files
=======================


Important Concepts
------------------------------

The internal representation of a RP66V1 files is as follows:

* The physical file consists of a Storage Unit Label followed by any number of Logical Files. Logical Files are independent from each other.
* Each Logical File consists of a number of Explicitly Formatted Logical Records (EFLRs) and optionally a single *Log Pass*.
* The *Log Pass* represents a single data collection run (example: "Repeat Section") and contains one or more *Frame Arrays*.
* A *Frame Array* is a number of frames of channel data.

Log Pass
^^^^^^^^^^^^^^

A :term:`Log Pass` represents a typical, independent, logging recording. A "Repeat Section" plus a "Main Log" are two, distinct, independent Log Passes.


Frame Array
^^^^^^^^^^^^^^

A :term:`Frame Array` is the logging data converted to the platforms internal types (usually C doubles) and stored in memory as a table where each row represents a particular depth (or time) and each column is the output of a specific channel. Each row is often referred to as a :term:`Frame`


Conceptual Model
^^^^^^^^^^^^^^^^^^^^^^

An example of a RP66V1 file might be one that contains two Logical Files representing, say, the "Repeat Section" and "Main Log". Each of these has a number of EFLRs and a Log Pass that contains two Frame Arrays, one is sampled every inch in depth and the other every six inches. The two Frame Arrays might have different channels.

A conceptual model of this physical RP66V1 file might be:

.. code-block:: console

    Physical File
    |-> Storage Unit Label
    |-> Logical File[0] "Repeat Section"
    |   |-> EFLRs
    |   |-> Log Pass
    |       |-> Frame Array at 1 inch spacing with channels A, B, C
    |       |-> Frame Array at 6 inch spacing with channels B, D, E
    |-> Logical File[1] "Main Log"
        |-> EFLRs
        |-> Log Pass
    |       |-> Frame Array at 1 inch spacing with channels A, B, C, X
    |       |-> Frame Array at 6 inch spacing with channels B, D, E, F



The following examples show how to iterate through a RP66V1 file and access the tables and frame data.
The code snippets here are all in :file:`example_data/RP66V1/demo_read.py`

.. warning:: At this version, |version|, these APIs are provisional, not final.


Reading :term:`RP66V1.EFLR` Tables
--------------------------------------

An :term:`RP66V1.Explicitly Formatted Logical Record` is a table of data organised in rows and columns.

As an example::

    from TotalDepth.RP66V1.core import File
    from TotalDepth.RP66V1.core import LogicalFile
    
    with open(path_in, 'rb') as fobj:
        rp66v1_file = File.FileRead(fobj)
        logical_index = LogicalFile.LogicalIndex(rp66v1_file, ident=path_in)
        for logical_file in logical_index.logical_files:
            for position, eflr in logical_file.eflrs:
                # This is quite verbose...
                print(eflr.str_long())

Produces this output (only the first two EFLRs are shown):

.. code-block:: console

    ExplicitlyFormattedLogicalRecord EFLR Set type: b'FILE-HEADER' name: b''>
      Template [2]:
        CD: 001 10100 L: b'SEQUENCE-NUMBER' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 10100 L: b'ID' C: 1 R: 20 (ASCII) U: b'' V: None
      Objects [1]:
        OBNAME: O: 2 C: 0 I: b'5'
          CD: 001 00001 L: b'SEQUENCE-NUMBER' C: 1 R: 20 (ASCII) U: b'' V: [b'       197']
          CD: 001 00001 L: b'ID' C: 1 R: 20 (ASCII) U: b'' V: [b'MSCT_197LTP                                                      ']
    <ExplicitlyFormattedLogicalRecord EFLR Set type: b'ORIGIN' name: b''>
      Template [20]:
        CD: 001 11100 L: b'FILE-ID' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'FILE-SET-NAME' C: 1 R: 19 (IDENT) U: b'' V: None
        CD: 001 11100 L: b'FILE-SET-NUMBER' C: 1 R: 18 (UVARI) U: b'' V: None
        CD: 001 11100 L: b'FILE-NUMBER' C: 1 R: 18 (UVARI) U: b'' V: None
        CD: 001 11100 L: b'FILE-TYPE' C: 1 R: 19 (IDENT) U: b'' V: None
        CD: 001 11100 L: b'PRODUCT' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'VERSION' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'PROGRAMS' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'CREATION-TIME' C: 1 R: 21 (DTIME) U: b'' V: None
        CD: 001 11100 L: b'ORDER-NUMBER' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11000 L: b'DESCENT-NUMBER' C: 1 R: 19 (IDENT) U: b'' V: None
        CD: 001 11000 L: b'RUN-NUMBER' C: 1 R: 19 (IDENT) U: b'' V: None
        CD: 001 11100 L: b'WELL-ID' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'WELL-NAME' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'FIELD-NAME' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'PRODUCER-CODE' C: 1 R: 16 (UNORM) U: b'' V: None
        CD: 001 11100 L: b'PRODUCER-NAME' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'COMPANY' C: 1 R: 20 (ASCII) U: b'' V: None
        CD: 001 11100 L: b'NAME-SPACE-NAME' C: 1 R: 19 (IDENT) U: b'' V: None
        CD: 001 11100 L: b'NAME-SPACE-VERSION' C: 1 R: 18 (UVARI) U: b'' V: None
      Objects [1]:
        OBNAME: O: 2 C: 0 I: b'DLIS_DEFINING_ORIGIN'
          CD: 001 00001 L: b'FILE-ID' C: 1 R: 20 (ASCII) U: b'' V: [b'MSCT_197LTP                                                      ']
          CD: 001 00001 L: b'FILE-SET-NAME' C: 1 R: 19 (IDENT) U: b'' V: [b'FAROE_PETROLEUM/206_05A-3']
          CD: 001 00001 L: b'FILE-SET-NUMBER' C: 1 R: 18 (UVARI) U: b'' V: [41]
          CD: 001 00001 L: b'FILE-NUMBER' C: 1 R: 18 (UVARI) U: b'' V: [167]
          CD: 001 00001 L: b'FILE-TYPE' C: 1 R: 19 (IDENT) U: b'' V: [b'STATION LOG']
          CD: 001 00001 L: b'PRODUCT' C: 1 R: 20 (ASCII) U: b'' V: [b'OP']
          CD: 001 00001 L: b'VERSION' C: 1 R: 20 (ASCII) U: b'' V: [b'19C0-187']
          CD: 001 01001 L: b'PROGRAMS' C: 4 R: 20 (ASCII) U: b'' V: [b'MSCT: Mechanical Sidewall Coring Tool', b'SGTP: Scintillation Gamma-Ray - P', b'LEHQT: Logging Equipment Head - QT', b'WELLCAD: WellCAD file generator']
          CD: 001 00001 L: b'CREATION-TIME' C: 1 R: 21 (DTIME) U: b'' V: [<<class 'TotalDepth.RP66V1.core.RepCode.DateTime'> 2011-08-20 22:48:50.000 DST>]
          CD: 001 00001 L: b'ORDER-NUMBER' C: 1 R: 20 (ASCII) U: b'' V: [b'BSAX-00003                                                                                                                     ']
          CD: 001 00001 L: b'DESCENT-NUMBER' C: 1 R: 19 (IDENT) U: b'' V: [b'-1']
          CD: 001 00001 L: b'RUN-NUMBER' C: 1 R: 19 (IDENT) U: b'' V: [b'1']
          CD: 001 00001 L: b'WELL-ID' C: 1 R: 20 (ASCII) U: b'' V: [b'                                                                                                                               ']
          CD: 001 00001 L: b'WELL-NAME' C: 1 R: 20 (ASCII) U: b'' V: [b'206/05a-3                                                                                                                      ']
          CD: 001 00001 L: b'FIELD-NAME' C: 1 R: 20 (ASCII) U: b'' V: [b'Fulla                                                                                                                          ']
          CD: 001 00001 L: b'PRODUCER-CODE' C: 1 R: 16 (UNORM) U: b'' V: [440]
          CD: 001 00001 L: b'PRODUCER-NAME' C: 1 R: 20 (ASCII) U: b'' V: [b'Schlumberger']
          CD: 001 00001 L: b'COMPANY' C: 1 R: 20 (ASCII) U: b'' V: [b'Faroe Petroleum                                                                                                                ']
          CD: 001 00001 L: b'NAME-SPACE-NAME' C: 1 R: 19 (IDENT) U: b'' V: [b'SLB']
          CD: 000 00000 L: b'NAME-SPACE-VERSION' C: 1 R: 18 (UVARI) U: b'' V: None


Reading :term:`EFLR` Contents
--------------------------------

Each value in a row/column is known as an ``Attribute`` which has the following properties:

============ ========= =======================================================================
Property     Type      Description
============ ========= =======================================================================
``label``    ``bytes`` The label identifying the Attribute.
``count``    ``int``   The number of the values the Attribute has.
``rep_code`` ``int``   The Representation Code of the values of the Attribute.
``units``    ``bytes`` The units of the value.
``value``    ``list``  The value itself.
============ ========= =======================================================================


The following code accesses the contents of every ``EQUIPMENT`` EFLR::

    with open(path_in, 'rb') as fobj:
        rp66v1_file = File.FileRead(fobj)
        logical_index = LogicalFile.LogicalIndex(rp66v1_file, path_in)
        for logical_file in logical_index.logical_files:
            for position, eflr in logical_file.eflrs:
                # eflr is a TotalDepth.RP66V1.core.LogicalRecord.EFLR.ExplicitlyFormattedLogicalRecord
                if eflr.set.type == b'EQUIPMENT':
                    for row in eflr.objects:
                        # row is a TotalDepth.RP66V1.core.LogicalRecord.EFLR.Object
                        print(f'    Row: {row.name.I}')
                        for attr in row.attrs:
                            # attr is a TotalDepth.RP66V1.core.LogicalRecord.EFLR.Attribute
                            print(f'        {attr.label}={attr.value} ({attr.units})')


Will produce something like this (output truncated):

.. code-block:: console


        Row: b'MSCT/MCFU_1/EQUIPMENT'
            b'LENGTH'=[125.0] (b'in')
            b'TRADEMARK-NAME'=[b'MCFU_1-AA'] (b'')
            b'PRESSURE'=[20000.0] (b'psi')
            b'STATUS'=[1] (b'')
            b'SERIAL-NUMBER'=[b'119.'] (b'')
            b'TEMPERATURE'=[350.0] (b'degF')
            b'VOLUME'=[1.5700000524520874] (b'ft3')
            b'MINIMUM-DIAMETER'=[5.25] (b'in')
            b'WEIGHT'=[144.0] (b'lbm')
        Row: b'MSCT/MCMU/EQUIPMENT'
            b'LENGTH'=[164.5] (b'in')
            b'TRADEMARK-NAME'=[b'MCMU-AA'] (b'')
            b'PRESSURE'=[20000.0] (b'psi')
            b'STATUS'=[1] (b'')
            b'SERIAL-NUMBER'=[b'65.'] (b'')
            b'TEMPERATURE'=[350.0] (b'degF')
            b'VOLUME'=[2.059999942779541] (b'ft3')
            b'MINIMUM-DIAMETER'=[5.25] (b'in')
            b'WEIGHT'=[580.0] (b'lbm')
        Row: b'MSCT/CORE_BIT/EQUIPMENT'
            b'LENGTH'=[1.0] (b'in')
            b'TRADEMARK-NAME'=[b'BIT-AA'] (b'')
            b'PRESSURE'=[20000.0] (b'psi')
            b'STATUS'=[1] (b'')
            b'SERIAL-NUMBER'=[b'0.'] (b'')
            b'TEMPERATURE'=[350.0] (b'degF')
            b'VOLUME'=[0.0] (b'ft3')
            b'MINIMUM-DIAMETER'=[1.0] (b'in')
            b'WEIGHT'=[1.0] (b'lbm')
            ...




Reading the Frame Data and accessing the numpy Arrays
--------------------------------------------------------

Reading the data into numpy arrays::

    with open(path_in, 'rb') as fobj:
        rp66v1_file = File.FileRead(fobj)
        logical_index = LogicalFile.LogicalIndex(rp66v1_file, ident=path_in)
        for logical_file in logical_index.logical_files:
            if logical_file.has_log_pass:
                for frame_array in logical_file.log_pass:
                    print(frame_array)
                    frame_count = LogicalFile.populate_frame_array(
                        rp66v1_file, logical_file, frame_array
                    )
                    print(
                        f'Loaded {frame_count} frames and {len(frame_array)} channels'
                        f' from {frame_array.ident} using {frame_array.sizeof_array} bytes.'
                    )
                    for channel in frame_array.channels:
                        print(channel.ident, channel.long_name, channel.units)
                        # channel.array is a numpy array
                        print(f'Min: {channel.array.min():12.3f} Max: {channel.array.max():12.3f}')


Would give this output:

.. code-block:: console

    FrameArray: ID: OBNAME: O: 2 C: 0 I: b'2000T' b''
      FrameChannel: OBNAME: O: 2 C: 4 I: b'TIME'            Rc:   2 Co:    1 Un: b'ms'        Di: [1] b'1 second River Time'
      FrameChannel: OBNAME: O: 2 C: 4 I: b'TDEP'            Rc:   2 Co:    1 Un: b'0.1 in'    Di: [1] b'1 second River Depth'
      FrameChannel: OBNAME: O: 2 C: 0 I: b'TENS_SL'         Rc:   2 Co:    1 Un: b'lbf'       Di: [1] b'Cable Tension'
      FrameChannel: OBNAME: O: 2 C: 0 I: b'DEPT_SL'         Rc:   2 Co:    1 Un: b'0.1 in'    Di: [1] b'Station logging depth'
    Loaded 921 frames and 4 channels from OBNAME: O: 2 C: 0 I: b'2000T' using 14736 bytes.
    OBNAME: O: 2 C: 4 I: b'TIME' b'1 second River Time' b'ms'
    Min: 16677259.000 Max: 17597260.000
    OBNAME: O: 2 C: 4 I: b'TDEP' b'1 second River Depth' b'0.1 in'
    Min:   852606.000 Max:   893302.000
    OBNAME: O: 2 C: 0 I: b'TENS_SL' b'Cable Tension' b'lbf'
    Min:     1825.000 Max:     2594.000
    OBNAME: O: 2 C: 0 I: b'DEPT_SL' b'Station logging depth' b'0.1 in'
    Min:   852606.000 Max:   893303.000
    
    FrameArray: ID: OBNAME: O: 2 C: 0 I: b'800T' b''
      FrameChannel: OBNAME: O: 2 C: 5 I: b'TIME'            Rc:   2 Co:    1 Un: b'ms'        Di: [1] b'400 milli-second time channel'
      FrameChannel: OBNAME: O: 2 C: 5 I: b'TDEP'            Rc:   2 Co:    1 Un: b'0.1 in'    Di: [1] b'MSCT depth channel'
      FrameChannel: OBNAME: O: 2 C: 1 I: b'ETIM'            Rc:   2 Co:    1 Un: b's'         Di: [1] b'Elapsed Logging Time'
      ... Lots more omitted
      FrameChannel: OBNAME: O: 2 C: 0 I: b'CMLP'            Rc:   2 Co:    1 Un: b'in'        Di: [1] b'Coring Motor Linear Position'
    Loaded 2301 frames and 43 channels from OBNAME: O: 2 C: 0 I: b'800T' using 395772 bytes.
    OBNAME: O: 2 C: 5 I: b'TIME' b'400 milli-second time channel' b'ms'
    Min: 16677259.000 Max: 17597260.000
    OBNAME: O: 2 C: 5 I: b'TDEP' b'MSCT depth channel' b'0.1 in'
    Min:   852606.000 Max:   893304.000
    OBNAME: O: 2 C: 1 I: b'ETIM' b'Elapsed Logging Time' b's'
    Min:        0.000 Max:      920.001
    ... Lots more omitted
    OBNAME: O: 2 C: 0 I: b'CMLP' b'Coring Motor Linear Position' b'in'
    Min:       -0.927 Max:        2.891


Limiting the Amount of Data Read
--------------------------------------

The RP66V1 Frame Array can be very large so to make it more manageable the :py:func:`TotalDepth.RP66V1.core.LogicalFile.populate_frame_array` can take the following, optional, arguments:

* `channels`: A sequence of channel identifiers. Only these channels will be populated into the numpy arrays in the Frame Array. The other channels will have a zero length numpy array. Channel 0, the X axis, will always be populated.
* To control the number of frames that are populated use either:

    * :py:class:`TotalDepth.common.Slice.Slice` which takes optional start, stop, step values that default to ``(0, len(data), 1)``. For example if there are 128 frames available then ``Slice(64, None, 2)`` would populate every other frame from frame 64 to the end.
    * :py:class:`TotalDepth.common.Slice.Split` which takes single integer, this is maximum number of frames to be populated and they will be evenly spaced throughout the Frame Array. For example if there are 128 available frames that ``Split(8)`` would populate the numpy arrays with every 16th frame.

For example, adding the two highlighted lines which populates every 64th frame and channels 1 and 2:

.. code-block:: python
    :emphasize-lines: 13,14
    
    from TotalDepth.RP66V1.core import File
    from TotalDepth.RP66V1.core import LogicalFile
    from TotalDepth.common import Slice

    with open(path_in, 'rb') as fobj:
        rp66v1_file = File.FileRead(fobj)
        logical_index = LogicalFile.LogicalIndex(rp66v1_file, ident=path_in)
        for logical_file in logical_index.logical_files:
            if logical_file.has_log_pass:
                for frame_array in logical_file.log_pass:
                    frame_count = LogicalFile.populate_frame_array(
                        rp66v1_file, logical_file, frame_array,
                        frame_slice=Slice.Slice(0, None, 64),
                        channels={frame_array.channels[1].ident, frame_array.channels[2].ident}
                    )
                    print(
                        f'Loaded {frame_count} frames'
                        f' from {frame_array.ident} using {frame_array.sizeof_array} bytes.'
                    )
                    for channel in frame_array.channels:
                        if len(channel.array):
                            print(channel.ident, channel.long_name, channel.units)
                            print(f'Min: {channel.array.min():12.3f} Max: {channel.array.max():12.3f}')
                    print()

Gives:

.. code-block:: console

    Loaded 15 frames from OBNAME: O: 2 C: 0 I: b'2000T' using 180 bytes.
    OBNAME: O: 2 C: 4 I: b'TIME' b'1 second River Time' b'ms'
    Min: 16677259.000 Max: 17573260.000
    OBNAME: O: 2 C: 4 I: b'TDEP' b'1 second River Depth' b'0.1 in'
    Min:   852606.000 Max:   892658.062
    OBNAME: O: 2 C: 0 I: b'TENS_SL' b'Cable Tension' b'lbf'
    Min:     1877.000 Max:     2561.000
    
    Loaded 36 frames from OBNAME: O: 2 C: 0 I: b'800T' using 432 bytes.
    OBNAME: O: 2 C: 5 I: b'TIME' b'400 milli-second time channel' b'ms'
    Min: 16677259.000 Max: 17573260.000
    OBNAME: O: 2 C: 5 I: b'TDEP' b'MSCT depth channel' b'0.1 in'
    Min:   852606.000 Max:   893135.188
    OBNAME: O: 2 C: 1 I: b'ETIM' b'Elapsed Logging Time' b's'
    Min:        0.000 Max:      896.001

